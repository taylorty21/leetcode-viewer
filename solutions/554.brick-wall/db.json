{"java":"class Solution {\n    // One pass: optimized version\n    public int leastBricks(List<List<Integer>> wall) {\n        int row = wall.size();\n        if (row == 0) return 0;\n        // Most frequent edge\n        int count = 0;\n        // edge to count map\n        Map<Integer, Integer> map = new HashMap<>();\n        \n        for(List<Integer> level : wall){\n            int sum = 0;\n            for(int i = 0; i < level.size() - 1; i++){\n                sum += level.get(i);\n                // Slower\n                // map.put(sum, map.getOrDefault(sum, 0) + 1);\n                // count = Math.max(count, map.get(sum));\n                \n                int val = map.get(sum) == null ? 1 : map.get(sum) + 1;\n                map.put(sum,val);\n                count = count < val ? val : count;\n            }\n        }\n        return row - count;\n    }\n    \n    // Two pass: initial idea, could be changed to one pass\n    public int leastBricks2(List<List<Integer>> wall) {\n        int sum = 0;\n        int maxSum = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (List<Integer> level: wall) {\n            for (int num: level) {\n                sum += num;\n                if (map.containsKey(sum)) {\n                    map.put(sum, map.get(sum) + 1);\n                } else {\n                    map.put(sum, 1);\n                }\n            }\n            maxSum = sum;\n            sum = 0;\n        }\n        int max = 0;\n        for (int key: map.keySet()) {\n           if (map.get(key) > max && (key != 0 && key != maxSum)) {\n               max = map.get(key);\n           } \n        }\n        return wall.size() - max;\n    }\n}"}