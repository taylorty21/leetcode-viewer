{"java":"/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\npublic class BSTIterator {\n    // Inorder traversal\n    private Stack<TreeNode> stack;\n    \n    public BSTIterator(TreeNode root) {\n        stack = new Stack<>();\n        // Add all the left nodes until reaching the most left node\n        while (root != null) {\n            stack.push(root);\n            root = root.left;\n        }\n    }\n\n    /** @return whether we have a next smallest number */\n    public boolean hasNext() {\n        return !stack.isEmpty();\n    }\n\n    /** @return the next smallest number */\n    public int next() {\n        TreeNode node = stack.pop();\n        TreeNode cur = node;\n        // if right is not null, need to get to the right.left because it's the next smallest node\n        if (cur.right != null) {\n            cur = cur.right;\n            while (cur != null) {\n                stack.push(cur);\n                if (cur.left != null) cur = cur.left;\n                else break;\n            }\n        }\n        return node.val;\n    }\n    \n    // Solution 2\n//     public BSTIterator2(TreeNode root) {\n//         stack = new Stack<>();\n//         // Add all the left nodes until reaching the most left node\n//         pushAll(root);\n//     }\n\n//     /** @return whether we have a next smallest number */\n//     public boolean hasNext2() {\n//         return !stack.isEmpty();\n//     }\n\n//     /** @return the next smallest number */\n//     public int next2() {\n//         TreeNode node = stack.pop();\n//         pushAll(node.right);\n//         return node.val;\n//     }\n    \n//     private void pushAll(TreeNode node) {\n//         while (node != null) {\n//             stack.push(node);\n//             node = node.left;\n//         }\n//     }\n    \n    // Solution 3 Similar to how we write Inorder traversal\n//     Stack<TreeNode> stack =  null ;            \n//     TreeNode current = null ;\n\n//     public BSTIterator(TreeNode root) {\n//           current = root;\t     \n//           stack = new Stack<> ();\n//     }\n\n//     /** @return whether we have a next smallest number */\n//     public boolean hasNext() {\t\t  \n//           return !stack.isEmpty() || current != null;  \n//     }\n\n//         /** @return the next smallest number */\n//     public int next() {\n//         while (current != null) {\n//             stack.push(current);\n//             current = current.left ;\n//         }\t\t\n//         TreeNode t = stack.pop() ;\t\t\n//         current = t.right ;\t\t\n//         return t.val ;\n//     }\n}\n\n/**\n * Your BSTIterator will be called like this:\n * BSTIterator i = new BSTIterator(root);\n * while (i.hasNext()) v[f()] = i.next();\n */"}