{"java":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\npublic class NestedIterator implements Iterator<Integer> {\n    Stack<NestedInteger> stack;\n    List<NestedInteger> nestedList;\n    \n    public NestedIterator(List<NestedInteger> nestedList) {\n        this.stack = new Stack<>();\n        for (int i = nestedList.size() - 1; i >= 0; i--) {\n            stack.push(nestedList.get(i));\n        }\n    }\n\n    @Override\n    public Integer next() {\n        if (hasNext()) {\n            return stack.pop().getInteger();\n        }\n        return null;\n    }\n\n    @Override\n    public boolean hasNext() {\n        while (!stack.isEmpty()) {\n            if (stack.peek().isInteger()) {\n                return true;\n            }\n            NestedInteger nestedInteger = stack.pop();\n            List<NestedInteger> nestedList = nestedInteger.getList();\n            for (int i = nestedList.size() - 1; i >= 0; i--) {\n                stack.push(nestedList.get(i));\n            }\n        }\n        return false;\n    }\n    \n//     Solution 1: \n//     private Stack<ListIterator<NestedInteger>> lists;\n//     public NestedIterator(List<NestedInteger> nestedList) {\n//         lists = new Stack<>();\n//         lists.push(nestedList.listIterator());\n//     }\n\n//     public Integer next() {\n//         hasNext();\n//         return lists.peek().next().getInteger();\n//     }\n\n//     public boolean hasNext() {\n//         while (!lists.empty()) {\n//             if (!lists.peek().hasNext()) {\n//                 lists.pop();\n//             } else {\n//                 NestedInteger x = lists.peek().next();\n//                 if (x.isInteger())\n//                     return lists.peek().previous() == x;\n//                 lists.push(x.getList().listIterator());\n//             }\n//         }\n//         return false;\n//     }\n    \n\n    \n//     Solution 2:\n//     NestedInteger nextInt;\n//     Stack<Iterator<NestedInteger>> stack;\n\n//     public NestedIterator(List<NestedInteger> nestedList) {\n//         stack = new Stack<Iterator<NestedInteger>>();\n//         stack.push(nestedList.iterator());\n//     }\n\n//     @Override\n//     public Integer next() {\n//         return nextInt != null ? nextInt.getInteger() : null; //Just in case\n//     }\n\n//     @Override\n//     public boolean hasNext() {\n//         while (!stack.isEmpty()) {\n//             if (!stack.peek().hasNext()) stack.pop();\n//             else if ((nextInt = stack.peek().next()).isInteger()) return true;\n//             else stack.push(nextInt.getList().iterator());\n//         }\n//         return false;\n//     }\n    \n    // Solution 3: Use Queue\n//     public NestedIterator(List<NestedInteger> nestedList) {\n//         make_queue(nestedList);\n//     }\n\n//     @Override\n//     public Integer next() {\n//         int t = queue.peek(); \n//         queue.poll();\n//         return t; \n//     }\n\n//     @Override\n//     public boolean hasNext() {\n//         return !queue.isEmpty();\n//     }\n    \n//     Queue<Integer> queue = new LinkedList<>();\n//     void make_queue(List<NestedInteger> nestedList) {\n//         for (NestedInteger a : nestedList) {\n//             if (a.isInteger()) queue.offer(a.getInteger());\n//             else make_queue(a.getList());\n//         }\n//     }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i = new NestedIterator(nestedList);\n * while (i.hasNext()) v[f()] = i.next();\n */"}