{"java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode buildTree2(int[] preorder, int[] inorder) {\n        return build(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1);  \n    }\n    \n    public TreeNode build(int[] preorder, int[] inorder, int ps, int pe, int is, int ie) {\n        if (ps > pe) {\n            return null;\n        }\n        TreeNode root = new TreeNode(preorder[ps]);\n        int pos = 0;\n        // Find the root in inorder\n        for (int i = is; i <= ie; i++){\n            if (inorder[i] == root.val){\n                pos = i;\n                break;\n            }\n        }\n        root.left = build(preorder, inorder, ps + 1, ps + pos - is, is, pos - 1);\n        //root.right = build(preorder, inorder, pe - ie + pos + 1, pe, pos + 1, ie);\n        root.right = build(preorder, inorder, ps + pos - is + 1, pe, pos + 1, ie);\n        return root;\n    }\n    \n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        int[] preIndex = new int[] { 0 }; \n        int[] inIndex = new int[] { 0 }; \n        return helperII(preorder, inorder, preIndex, inIndex, Integer.MAX_VALUE); \n    } \n \n    private TreeNode helperII(int[] pre, int[] in, int[] preIndex, int[] inIndex, int target) { \n        // Traversing and construct the binary tree using preOrder and inOrder, \n        // the preOrder is [root][left subtree][right subtree] \n        // from the preOrder, we know the root of the binary tree, \n        // the inOrder is [left subtree][root][right subtree] \n        // when we know the root, we actually know the boundary of \n        // the left/right subtree. \n        // The \"target\" is actually the root, and we are using inOrder \n        // to identify the boundary of left subtree. \n        if (inIndex[0] >= in.length || in[inIndex[0]] == target) {\n            return null; \n        } \n        TreeNode root = new TreeNode(pre[preIndex[0]]); \n        // preOrder, advance the index by 1 since we already finish the root. \n        preIndex[0]++; \n        root.left = helperII(pre, in, preIndex, inIndex, root.val); \n        // inOrder, after finish the left subtree, we can advance the index by 1. \n        inIndex[0]++; \n        root.right = helperII(pre, in, preIndex, inIndex, target); \n        return root; \n    }\n}"}