{"java":"/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    // Creating new intervals and add them to the List, not adding the input one\n    // take the first interval and compare its end with the next intervals starts. As long as they overlap, we update the end to be the max end of the overlapping intervals. \n    // Once find a non overlapping interval, add the previous \"extended\" interval and start over (reset the start and end bounds).\n    // Sorting takes O(n log(n)) and merging the intervals takes O(n) => O(n log(n)).\n    public List<Interval> merge(List<Interval> intervals) {\n        if (intervals.size() <= 1) return intervals;\n        // Sort based on start\n        Collections.sort(intervals, new Comparator<Interval>(){\n            @Override\n            public int compare(Interval obj0, Interval obj1) {\n                return obj0.start - obj1.start;\n            }\n        });\n        \n        List<Interval> res = new ArrayList<>();\n        int start = intervals.get(0).start;\n        int end = intervals.get(0).end;\n        for (Interval interval: intervals) {\n            // Overlapping\n            if (interval.start <= end) {\n                // Update the end to be the max end of the overlapping intervals\n                // [[1,4],[2,3]] the previous end might be larger than the current end\n                end = Math.max(interval.end, end);\n            } else {\n                res.add(new Interval(start, end));\n                start = interval.start;\n                end = interval.end;\n            }\n        }\n        res.add(new Interval(start, end));\n        return res;\n    }\n}"}