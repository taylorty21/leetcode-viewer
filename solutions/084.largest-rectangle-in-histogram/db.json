{"java":"class Solution {\n    // Linear scan and then look back => use stack\n    // Use a stack to store all the indices of the columns that form an ascending order\n    public int largestRectangleArea2(int[] heights) {\n        if (heights == null || heights.length == 0) return 0;\n        int maxArea = 0;\n        Stack<Integer> stack = new Stack<>();\n        int leftMost = 0, rightMost = 0, index = 0;\n        int i = 0;\n        while (i <= heights.length) {\n            if (stack.isEmpty() || heights[i] >= heights[stack.peek()]) {\n                stack.push(i);\n                i++;\n            } else {\n                index = stack.pop();\n                rightMost = i;\n                while (!stack.isEmpty() && heights[index] == heights[stack.peek()]) {\n                    index = stack.pop();\n                }\n                leftMost = (stack.isEmpty()) ? -1 : stack.peek();\n                maxArea = Math.max(maxArea, (rightMost - leftMost - 1) * heights[index]);\n                // Right is the number after right edge, left is the number before left edge. Need to minus one.\n            }\n        }\n        rightMost = stack.peek() + 1;\n        while (!stack.isEmpty()) {\n            index = stack.pop();\n            leftMost = (stack.isEmpty()) ? -1 : stack.peek();\n            maxArea = Math.max(maxArea, (rightMost - leftMost - 1) * heights[index]);\n        }\n        return maxArea;\n    }\n    \n    public int largestRectangleArea(int[] heights) {\n        if (heights == null || heights.length == 0) return 0;\n        int maxArea = 0;\n        Stack<Integer> stack = new Stack<>();\n        int leftMost = 0, rightMost = 0, index = 0;\n        int i = 0;\n        while (i <= heights.length) {\n            int h = (i == heights.length ? 0 : heights[i]);\n            if (stack.isEmpty() || h >= heights[stack.peek()]) {\n                stack.push(i);\n                i++;\n            } else {\n                index = stack.pop();\n                rightMost = i;\n                while (!stack.isEmpty() && heights[index] == heights[stack.peek()]) {\n                    index = stack.pop();\n                }\n                leftMost = (stack.isEmpty()) ? -1 : stack.peek();\n                maxArea = Math.max(maxArea, (rightMost - leftMost - 1) * heights[index]);\n                // Right is the number after right edge, left is the number before left edge. Need to minus one.\n            }\n        }\n        return maxArea;\n    }\n}"}