{"java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    // Method 1: Merge two sorted lists each time. Like merge sort\n    // Method 2: Binary Reduction\n    // Time: nlogk where k is the number of lists and n is total number of nodes.\n    // merge takes O(n) time and partition takes O(logk) time\n    public static ListNode mergeKLists2(ListNode[] lists){\n        return partion(lists,0,lists.length-1);\n    }\n\n    public static ListNode partion(ListNode[] lists,int s,int e){\n        if(s==e)  return lists[s];\n        if(s<e){\n            int q=(s+e)/2;\n            ListNode l1=partion(lists,s,q);\n            ListNode l2=partion(lists,q+1,e);\n            return merge(l1,l2);\n        }else\n            return null;\n    }\n\n    //This function is from Merge Two Sorted Lists.\n    public static ListNode merge(ListNode l1,ListNode l2){\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        if(l1.val<l2.val){\n            l1.next=merge(l1.next,l2);\n            return l1;\n        }else{\n            l2.next=merge(l1,l2.next);\n            return l2;\n        }\n    }\n\n    // Method 3: k pointers, use min heap\n    // If there are n*k elements\n    // Time: O(k*logk*n)\n    // Space: O(k)\n    // you can think about the complexity on each node and expand. For each node, the complexity is O(logk), which is the complexity for adding to the PQ, and there are k*n that many of nodes, which gives us O(knlogk).\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) return null;\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>(11, \n         new Comparator<ListNode>() {\n             @Override\n             public int compare(ListNode n1, ListNode n2) {\n                if (n1.val == n2.val) return 0;\n                return n1.val < n2.val? -1 : 1;\n             }\n         });\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        for (ListNode listNode: lists) {\n            if (listNode != null) minHeap.offer(listNode);\n        }\n        \n        while (!minHeap.isEmpty()) {\n            curr.next = minHeap.poll();\n            if (curr.next.next != null) {\n                minHeap.offer(curr.next.next);\n            }\n            curr = curr.next;\n        }\n        return dummy.next;\n    }\n}"}