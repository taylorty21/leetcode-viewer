{"java":"class Solution {\n    // Use two hash sets\n    // Time complexity: O(n)\n    public int[] intersection(int[] nums1, int[] nums2) {\n        Set<Integer> set = new HashSet<>();\n        Set<Integer> intersect = new HashSet<>();\n        for (int i = 0; i < nums1.length; i++) {\n            set.add(nums1[i]);\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            if (set.contains(nums2[i])) {\n                intersect.add(nums2[i]);\n            }\n        }\n        int[] result = new int[intersect.size()];\n        int i = 0;\n        for (Integer num : intersect) {\n            result[i++] = num;\n        }\n        return result;\n    }\n    \n    // Sort both arrays, use two pointers\n    // Time complexity: O(nlogn)\n\n    public int[] intersection2(int[] nums1, int[] nums2) {\n        Set<Integer> set = new HashSet<>();\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int i = 0;\n        int j = 0;\n        while (i < nums1.length && j < nums2.length) {\n            if (nums1[i] < nums2[j]) {\n                i++;\n            } else if (nums1[i] > nums2[j]) {\n                j++;\n            } else {\n                set.add(nums1[i]);\n                i++;\n                j++;\n            }\n        }\n        int[] result = new int[set.size()];\n        int k = 0;\n        for (Integer num : set) {\n            result[k++] = num;\n        }\n        return result;\n    }\n\n    // Binary search\n    // Time complexity: O(nlogn)\n    public int[] intersection3(int[] nums1, int[] nums2) {\n        Set<Integer> set = new HashSet<>();\n        Arrays.sort(nums2);\n        for (Integer num : nums1) {\n            if (binarySearch(nums2, num)) {\n                set.add(num);\n            }\n        }\n        int i = 0;\n        int[] result = new int[set.size()];\n        for (Integer num : set) {\n            result[i++] = num;\n        }\n        return result;\n    }\n    \n    public boolean binarySearch(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target) {\n                return true;\n            }\n            if (nums[mid] > target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return false;\n    }\n}\n"}